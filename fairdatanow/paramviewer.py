# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/12_dataviewer.ipynb.

# %% auto 0
__all__ = ['DataViewer']

# %% ../notebooks/12_dataviewer.ipynb 5
import panel as pn
import param
from panel.viewable import Viewer
import pandas as pd
from humanize import naturalsize
import nc_py_api
import re
import os

pn.extension("tabulator")

# %% ../notebooks/12_dataviewer.ipynb 6
class DataViewer(Viewer):
    # DataFrames
    data = param.DataFrame()
    filtered_data = param.DataFrame()
    # list filters
    columns = param.ListSelector(default=["path", "size", "modified"])
    extensions = param.ListSelector(default=[])
    # typed filters
    search = param.String(default="xray")
    bytes_amount = param.Integer()
    show_directories = param.Boolean(default=False)
    show_filters = param.Boolean(default=False)

    #non param attributes
    nc_py_api.options.NPA_NC_CERT = False 

    def __init__(self, configuration, subdir=None, **params):
        super().__init__(**params)
        self.nc = self._create_connector(configuration)
        # load all param attributes where necessary
        self.data = self._load_dataframe(subdir)
        self.param.columns.objects = self.data.columns.to_list()
        self.param.extensions.objects = self.data['ext'].unique()

    def _create_connector(self, configuration):
        # parse configuration 
        m = re.match('(^https://[^/]+/)(.*)', configuration['url'])
        nextcloud_url, self.cache_dir = m.groups()
        nc_auth_user = configuration['user']
        nc_auth_pass = configuration['password']
        
        return nc_py_api.Nextcloud(nextcloud_url=nextcloud_url,
                                   nc_auth_user=nc_auth_user,
                                   nc_auth_pass=nc_auth_pass)

    @pn.cache()
    def _load_dataframe(self, subdir):
        if subdir is None:
            subdir = self.cache_dir

        fsnodes = self.nc.files.listdir(subdir, depth=-1, exclude_self=False)

        data = [{'path': fsnode.user_path,
                'size': naturalsize(fsnode.info.size, True),
                'ext': os.path.splitext(fsnode.user_path)[1].lower(),
                'byte_size': fsnode.info.size,
                'modified': fsnode.info.last_modified,
                'isdir': fsnode.is_dir
                } for fsnode in fsnodes]
        
        return pd.DataFrame(data)
        
        
    @param.depends("data", "columns", "search", "extensions", "show_directories", watch=True)
    def _update_filtered_data(self):
        # set the base df for readability and a non-watched variable
        df = self.data
        # search the dataframe in column path if it contains the search string
        df = df[df["path"].str.contains(self.search)]
        # filter to only include the extensions that are selected
        if self.extensions:
            df = df[df["ext"].isin(self.extensions)]
        # save the total bytes_size in the bytes_amount variable
        self.bytes_amount = df[df["isdir"] == False]["byte_size"].sum()
        # if show_directories is turned off exclude them from the df
        if not self.show_directories:
            df = df[df["isdir"] == False]
        # only select the columns from the column selector
        self.filtered_data = df[self.columns]
    
    @param.depends("filtered_data")
    def number_of_rows(self):
        return f"Showing {len(self.filtered_data)} out of {len(self.data)} rows | Total size: {naturalsize(self.bytes_amount, True)}"

    @param.depends("show_filters")
    def make_widgetbox(self):
        if self.show_filters:
            self.filter_menu = pn.WidgetBox('# Filters',
                                            pn.widgets.MultiChoice.from_param(self.param.columns),
                                            pn.widgets.MultiChoice.from_param(self.param.extensions),
                                            pn.widgets.Checkbox.from_param(self.param.show_directories)
                                           )
            return self.filter_menu
        self.filter_menu = None
        
    
    def __panel__(self):
        return pn.Column(
            pn.Row(pn.widgets.TextInput.from_param(self.param.search), 
                   pn.widgets.Checkbox.from_param(self.param.show_filters),
                   self.make_widgetbox
                  ),
            pn.widgets.Tabulator(self.param.filtered_data, height=350, pagination=None, show_index=False, selectable=True, disabled=True),
            self.number_of_rows
        )
