"""Another try using panel"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/11_exploring-your-remote-data-with-tabulator.ipynb.

# %% auto 0
__all__ = ['to_iframe', 'RemoteData2']

# %% ../notebooks/11_exploring-your-remote-data-with-tabulator.ipynb 14
import nc_py_api 
from nc_py_api import Nextcloud
import panel as pn
import param 
import humanize
import pandas as pd
import os 
import re
import html 
import time
from pathlib import Path
import ipynb_path

# %% ../notebooks/11_exploring-your-remote-data-with-tabulator.ipynb 15
pn.extension('tabulator')


def _node_to_dataframe2(fsnode): 
    '''Convert `fsnode` object to polars a single row polars dataframe.'''

    df = pd.DataFrame({'path': [fsnode.user_path],
                       'size': [humanize.naturalsize(fsnode.info.size, True)],
                       'ext': [os.path.splitext(fsnode.user_path)[1].lower()],
                       'byte_size': [fsnode.info.size],
                       'modified': [fsnode.info.last_modified], 
                       'isdir': [fsnode.is_dir]})

    return df 

def to_iframe(panel_layout, html_file, height=500): 
    '''Save `panel_layout` object  as full HTML page `html_file` in *iframes* subfolder. 

    Returns: `iframe_link` 
    
    In this way it should be possible to preserve rich interactive visualizations directly in web pages.

    See: https://panel.holoviz.org/reference/panes/HTML.html#html-documents  
    '''
    
    # Create iframes subfolder 
    notebooks_dir = os.path.dirname(ipynb_path.get())
    iframes_dir = os.path.join(notebooks_dir, 'iframes')
    os.makedirs(iframes_dir, exist_ok=True)
    
    # Save the plot as html file to iframes subfolder 
    html_path = os.path.join(iframes_dir, html_file)
    panel_layout.save(html_path)
    
    iframe_link = f'<iframe width="100%" height="{height}" src="iframes/{html_file}" title="link"></iframe>'

    return iframe_link

    

class RemoteData2(object): 
    
    # See: https://help.nextcloud.com/t/using-nc-py-api-i-cant-download-any-file-due-to-ssl-certificte-verify-failed/194019 
    nc_py_api.options.NPA_NC_CERT = False 

    def __init__(self, configuration): 
        '''Recursively scan the contents of a remote webdav server as specified by `configuration`. 
        '''

        # parse configuration 
        m = re.match('(^https://[^/]+/)(.*)', configuration['url'])
        nextcloud_url, self.cache_dir = m.groups()
        nc_auth_user = configuration['user']
        nc_auth_pass = configuration['password'] 
               
        # Instantiate Nextcloud client 
        self.nc = Nextcloud(nextcloud_url=nextcloud_url, nc_auth_user=nc_auth_user, nc_auth_pass=nc_auth_pass) 
        

    def listdir(self, subdir=None, search_regex='', searchBuilder={}, show_directories=False): 
        '''Create interactive file table for remote subdirectory `subdir`. 

        If subdir is not specified the complete project directory is scanned.
        '''

        if subdir is None: 
            subdir = self.cache_dir 

        print(f'Please wait while scanning all file paths in remote folder...') 
            
        # query webdav server to obtain file listing 
        fs_nodes_list = self.nc.files.listdir(subdir, depth=-1, exclude_self=False) 
        
        n_paths = len(fs_nodes_list)

        # initialize pandas dataframe with first row to fix schema 
        self.df = _node_to_dataframe2(fs_nodes_list[0]) 
         
        for fsnode in fs_nodes_list[1:]: 
            self.df = pd.concat([self.df, _node_to_dataframe2(fsnode)], ignore_index=True)

        if not show_directories:
            self.df = self.df[self.df['isdir'] == False]

        self.df.reset_index()

        self.layout = self._build_layout()

        return self.layout 

    def download_selected(self, cache_dir=None):
        '''Download selected files (blue rows) from `table` to default local cache directory. 
        
        A custom `cache_dir` can be specified. '''
        
        # create cache path 
        if cache_dir is None: 
            cache_path = Path.home().joinpath('.cache', 'fairdatanow')
        else: 
            cache_path = Path.home().joinpath('.cache', cache_dir)
    
        os.makedirs(cache_path, exist_ok=True)
    
        # obtain remote paths and remote timestamps 
        local_path_list = []
        remote_path_list = self.file_table.selected_dataframe['path'].tolist()
        remote_modified_list = self.file_table.selected_dataframe['modified'].tolist()
        remote_isdir_list = self.file_table.selected_dataframe['isdir'].tolist()
        
        n_files = len(remote_path_list)
       
        for i, [remote_path, remote_modified, remote_isdir] in enumerate(zip(remote_path_list, remote_modified_list, remote_isdir_list)): 
    
            # only download actual files 
            if not remote_isdir:   
                remote_directory = os.path.dirname(remote_path)
                local_directory = cache_path.joinpath(remote_directory) # I guess this will not yet work for Windows
                
                # create directory structure inside cache 
                os.makedirs(local_directory, exist_ok=True) 
            
                # get remote epoch time  
                remote_modified_epoch_time = remote_modified.timestamp()
            
                # construct corresponding local path 
                local_path = cache_path.joinpath(remote_path) 
                local_path_list.append(str(local_path))
                
            
                # check if local file exists and if modification times are similar 
                is_local = local_path.exists()  
            
                is_similar = False 
                local_modified_epoch_time = None 
                if is_local: 
                    local_modified_epoch_time = os.stat(local_path).st_mtime
                    if local_modified_epoch_time == remote_modified_epoch_time: 
                        is_similar = True 
                        
                # download from nextcloud 
                if not is_similar: 
                    print(f'[{i+1}/{n_files}] Timestamps do no match: {remote_modified_epoch_time} vs {local_modified_epoch_time}', end='\r')
                    print(f'[{i+1}/{n_files}] Downloading to: {local_path}                                                       ' , end='\r')
                      
                    # write to cache 
                    with open(local_path, 'bw') as fh: 
                        self.nc.files.download2stream(remote_path, fh) 
                        
                    # adjust last modified timestamp 
                    now = int(time.time())
                    os.utime(local_path, (now, remote_modified_epoch_time)) 
                    
        print(f"Ready with downloading {n_files} selected remote files to local cache: {cache_path}                                                                      ")

        return local_path_list
    
    def _build_layout(self):
        # panel components

        # top filters
        self.search_filter = pn.widgets.TextInput(name='Search filter', value='xray') 
        self.type_select = pn.widgets.MultiChoice(name='filter extensions',options=self.df['ext'].unique().tolist())

        # put filters in a row
        self.top_row = pn.Row(self.search_filter, self.type_select)

        # middle table 
        # selectable=True implies that by (shift/Ctrl) clicking you can select and deselect rows 
        # disabled=True implies thatyou can not edit the table 
        self.file_table = pn.widgets.Tabulator(self.df, height=350, pagination=None, show_index=False, selectable=True, disabled=True)

        # bottom information
        self.row_counter = pn.pane.Str(f"Showing {len(self.df)} out of {len(self.df)} rows")

        # add filters to the table
        self.file_table.add_filter(pn.bind(self._contains_filter, pattern=self.search_filter, column='path'))
        self.file_table.add_filter(self.type_select, 'ext')

        # add a watcher to the multichoice
        self.type_select.param.watch(self._update_ext_filter, 'value')

        # return the layout
        return pn.Column(self.top_row, self.file_table, self.row_counter)

    def _update_ext_filter(self, event):
        '''Updates the row counter everytime a change is made in the MultiChoice widget.'''
        self._update_row_counter(self.file_table.current_view)
    
    def _contains_filter(self, df, pattern, column): 
        '''String contains `pattern` filter function on 'column` of dataframe `df`. '''
        
        if not pattern:
            self._update_row_counter(df)
            return df 
            
        filtered_df = df[df[column].str.contains(pattern)]
        
        self._update_row_counter(filtered_df)
        
        return filtered_df
    
    def _update_row_counter(self, filtered_df):
        '''Updates the value of the row counter'''
        file_df = filtered_df[filtered_df['isdir'] == False]
        total_bytes = file_df['byte_size'].sum()
        total_size = humanize.naturalsize(total_bytes, True)
        self.row_counter.object = f"Showing {len(filtered_df)} out of {len(self.df)} rows, size: {total_size}"

